#!/bin/bash
# Test: End-to-End NAS Backup Workflow
# This test runs from the HOST (not inside VM)
# Tests: Primary VM has script → Start NAS VM → NAS runs script → Verify backups → Cleanup

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/test-utils.sh"

setup_test_env "${BASH_SOURCE[0]}"
print_test_header "Test End-to-End NAS Backup Workflow (Host-Side)"

SCRIPT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
NAS_SCRIPT_NAME="nas-backup-client.sh"
NAS_SCRIPT_PATH="${SCRIPT_ROOT}/${NAS_SCRIPT_NAME}"

# Cleanup function
cleanup() {
    printf "\n${CYAN}Cleaning up test resources:${NC}\n"

    # Clean NAS backup directory
    if vagrant status nas 2>/dev/null | grep -q "running"; then
        printf "  Cleaning NAS backup directory...\n"
        vagrant ssh nas -c "sudo rm -rf /mnt/nas-backup/*.tar.gz" 2>/dev/null || true
    fi

    # Remove generated NAS script
    if [[ -f "$NAS_SCRIPT_PATH" ]]; then
        printf "  Removing NAS backup script: %s\n" "$NAS_SCRIPT_PATH"
        rm -f "$NAS_SCRIPT_PATH"
    fi

    # Destroy VMs
    printf "  Destroying test VMs...\n"
    vagrant destroy -f primary nas 2>/dev/null || true

    printf "  Cleanup completed\n"
}

trap cleanup EXIT

# Test 1: Check if Primary VM is running
printf "\n${CYAN}Step 1: Checking Primary VM status:${NC}\n"

if ! vagrant status primary 2>/dev/null | grep -q "running"; then
    print_test_result "SKIP" "Primary VM not running - full lifecycle test should start it"
    print_test_summary
    exit 0
fi

assert_true "0" "Primary VM is running"

# Test 2: Check if NAS backup script exists (should be generated by test 03)
printf "\n${CYAN}Step 2: Checking for generated NAS script:${NC}\n"

if [[ ! -f "$NAS_SCRIPT_PATH" ]]; then
    print_test_result "SKIP" "NAS script not found - test 03 should generate it: $NAS_SCRIPT_PATH"
    print_test_summary
    exit 0
fi

assert_file_exists "$NAS_SCRIPT_PATH" "NAS backup script exists"

# Verify script is executable
if [[ -x "$NAS_SCRIPT_PATH" ]]; then
    assert_true "0" "Script is executable"
else
    assert_true "1" "Script should be executable"
    exit 1
fi

SCRIPT_SIZE=$(du -h "$NAS_SCRIPT_PATH" | cut -f1)
printf "  Script size: %s\n" "$SCRIPT_SIZE"

# Test 3: Start NAS VM if not running
printf "\n${CYAN}Step 3: Starting NAS VM:${NC}\n"

if vagrant status nas 2>/dev/null | grep -q "running"; then
    printf "  NAS VM already running\n"
    assert_true "0" "NAS VM is running"
else
    printf "  Bringing up NAS VM...\n"
    if vagrant up nas >/dev/null 2>&1; then
        assert_true "0" "NAS VM started successfully"
    else
        assert_true "1" "Failed to start NAS VM"
        exit 1
    fi
fi

# Test 4: Setup NAS backup directory
printf "\n${CYAN}Step 4: Preparing NAS backup directory:${NC}\n"

vagrant ssh nas -c "sudo mkdir -p /mnt/nas-backup && sudo chown vagrant:vagrant /mnt/nas-backup && sudo rm -f /mnt/nas-backup/*.tar.gz" >/dev/null 2>&1

if vagrant ssh nas -c "test -d /mnt/nas-backup && test -w /mnt/nas-backup" 2>/dev/null; then
    assert_true "0" "NAS backup directory prepared"
else
    assert_true "1" "Failed to prepare NAS backup directory"
    exit 1
fi

# Test 5: Check backups exist on Primary
printf "\n${CYAN}Step 5: Checking backups on Primary VM:${NC}\n"

BACKUP_COUNT=$(vagrant ssh primary -c "sudo find /opt/backup -name 'docker_backup_*.tar.gz' 2>/dev/null | wc -l" 2>/dev/null | tr -d ' \r')

printf "  Backups on Primary: %s\n" "$BACKUP_COUNT"

if [[ $BACKUP_COUNT -eq 0 ]]; then
    print_test_result "SKIP" "No backups on Primary - create one first"
    print_test_summary
    exit 0
fi

assert_true "0" "Backups available on Primary for sync"

# Test 6: Run NAS backup script from NAS VM
printf "\n${CYAN}Step 6: Running NAS backup script from NAS VM:${NC}\n"

set +e
NAS_RUN_OUTPUT=$(vagrant ssh nas -c "cd ~/docker-stack-backup && ./$NAS_SCRIPT_NAME" 2>&1)
NAS_RUN_EXIT=$?
set -e

if [[ $NAS_RUN_EXIT -eq 0 ]]; then
    assert_true "0" "NAS backup script executed successfully"
else
    printf "  Script output:\n%s\n" "$NAS_RUN_OUTPUT"
    assert_true "1" "NAS backup script failed to execute"
    exit 1
fi

# Test 7: Verify backups were synced to NAS
printf "\n${CYAN}Step 7: Verifying backup sync to NAS:${NC}\n"

NAS_BACKUP_COUNT=$(vagrant ssh nas -c "find /mnt/nas-backup -name 'docker_backup_*.tar.gz' 2>/dev/null | wc -l" 2>/dev/null | tr -d ' \r')

printf "  Backups on Primary: %s\n" "$BACKUP_COUNT"
printf "  Backups on NAS: %s\n" "$NAS_BACKUP_COUNT"

if [[ $NAS_BACKUP_COUNT -gt 0 ]]; then
    assert_true "0" "Backups successfully synced to NAS"

    # List backups on NAS
    printf "\n${CYAN}Backups on NAS:${NC}\n"
    vagrant ssh nas -c "ls -lh /mnt/nas-backup/*.tar.gz 2>/dev/null" 2>/dev/null | while read -r line; do
        printf "    %s\n" "$line"
    done
else
    assert_true "1" "No backups found on NAS after sync"
    exit 1
fi

# Test 8: Verify backup integrity on NAS
printf "\n${CYAN}Step 8: Verifying backup integrity on NAS:${NC}\n"

LATEST_NAS_BACKUP=$(vagrant ssh nas -c "find /mnt/nas-backup -name 'docker_backup_*.tar.gz' | sort -r | head -1" 2>/dev/null | tr -d '\r')

if [[ -n "$LATEST_NAS_BACKUP" ]]; then
    if vagrant ssh nas -c "tar -tzf '$LATEST_NAS_BACKUP' >/dev/null 2>&1" 2>/dev/null; then
        assert_true "0" "NAS backup is a valid tar archive"
    else
        assert_true "1" "NAS backup archive is corrupted"
    fi
fi

# Test 9: Test retention cleanup on NAS
printf "\n${CYAN}Step 9: Testing retention cleanup on NAS:${NC}\n"

# Create some fake old backups (35, 70, 105, 140, 175 days old - all beyond 30-day retention)
printf "  Creating test old backups on NAS...\n"
for i in {1..5}; do
    # Use date command compatible with both Linux and macOS
    OLD_DATE=$(date -d "$((i * 35)) days ago" +%Y%m%d_%H%M%S 2>/dev/null || date -v-$((i * 35))d +%Y%m%d_%H%M%S 2>/dev/null)
    vagrant ssh nas -c "touch /mnt/nas-backup/docker_backup_${OLD_DATE}.tar.gz" 2>/dev/null
done

# Count before cleanup
BEFORE_CLEANUP=$(vagrant ssh nas -c "find /mnt/nas-backup -name 'docker_backup_*.tar.gz' | wc -l" 2>/dev/null | tr -d ' \r')
printf "  Backups before cleanup: %s\n" "$BEFORE_CLEANUP"

# Run script again to trigger retention cleanup
printf "  Running script again to trigger cleanup...\n"
vagrant ssh nas -c "cd ~/docker-stack-backup && ./$NAS_SCRIPT_NAME" >/dev/null 2>&1

# Count after cleanup
AFTER_CLEANUP=$(vagrant ssh nas -c "find /mnt/nas-backup -name 'docker_backup_*.tar.gz' | wc -l" 2>/dev/null | tr -d ' \r')
printf "  Backups after cleanup: %s\n" "$AFTER_CLEANUP"

# Old fake backups should be cleaned up (retention is 30 days)
if [[ $AFTER_CLEANUP -lt $BEFORE_CLEANUP ]]; then
    assert_true "0" "Retention cleanup removed old backups"
else
    print_test_result "WARN" "Retention cleanup may not have removed all expected old backups"
fi

printf "\n${CYAN}End-to-End NAS Backup Workflow Summary:${NC}\n"
printf "  ✓ Primary VM running with backups\n"
printf "  ✓ NAS client script generated with embedded SSH key\n"
printf "  ✓ NAS VM started successfully\n"
printf "  ✓ Script executed successfully from NAS VM\n"
printf "  ✓ NAS connected back to Primary (192.168.56.10)\n"
printf "  ✓ Backups synced from Primary → NAS (192.168.56.20)\n"
printf "  ✓ Backup integrity verified on NAS\n"
printf "  ✓ Retention cleanup working on NAS (30-day retention)\n"

print_test_summary

# Note: Cleanup and VM destruction happens automatically via trap EXIT
